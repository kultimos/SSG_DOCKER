1.关于容器卷的一个坑
    --privileged=true
    Docker容器中的进程默认是没有root权限的,这就意味着,在容器中是无法执行一些需要root权限的命令的,
    比如mount,所以,如果我们需要在容器中挂载一个数据卷,就需要加上--privileged=true参数,这样容器中的进程就会在挂载时获得root权限,否则,就会报错
    可以简单的认为加了这个命令来运行一个容器可以使容器内部拥有宿主机的root权限

2.如何理解容器卷
    这是我们之前本地运行私有库的命令:   docker run -d -p 5000:5000 -v/zzyyuse/myregistry/:/tmp/registry --privileged=true registry
        -v表示 添加自定义容器卷,挂载目录,将容器中的/tmp/registry目录挂载到宿主机的/zzyyuse/myregistry/目录下

    容器数据卷主要的功能是将容器内的数据持久化到宿主机上,即使容器被删除,数据也不会丢失
    卷的设计目的就是数据的持久化,完全独立于容器的生命周期,因此,docker不会在容器被删除时,删除其挂载的数据卷,也不会在容器被其他容器替换时,删除原先容器的数据卷;
这就使得数据卷的生命周期一直持续到没有容器使用它为止

3.运行一个带有容器卷存储功能的容器实例
    docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名
    docker run -it --privileged=true -v /usr/local/tmp/host_data:/usr/local/tmp/u_data --name=u1  ubuntu
    这里最后的--name=suiBianXie是开启一个容器,并给这个容器起一个名字,这样方便我们后续操作,比如进入容器内部,就可以直接docker exec -it suibianxie /bin/bash

    docker inspect 容器名/容器ID :可以查看容器的详细信息,包括容器卷的挂载信息

4.容器卷的作用
    将运用与运行的环境打包镜像后,run后形成容器实例运行,但是我们对数据的要求是希望持久化,这时候就需要容器卷了
    1：数据卷可在容器之间共享或重用数据
    2：卷中的更改可以实时生效(容器卷内修改实时同步到主机目录,并且是双向同步,但是感觉双向同步这种说法不是很严谨,因为当我们docker服务挂掉后,对主机指定目录的修改数据仍然会在docker重启后同步到对应绑定目录,
所以,更像是docker直接在宿主机下进行读写文件)
    3：数据卷中的更改不会包含在镜像的更新中
    4：数据卷的生命周期一直持续到没有容器使用它为止

5.容器卷的使用
    1.卷中的更改可以实时生效(容器卷内修改实时同步到主机目录,并且是双向同步)
    2.当我们建立了一个数据卷后,docker服务挂掉,此时在主机的绑定目录中操作,重启docker服务后,可以在docker的目录中看到主机之前修改的内容
    3.可以设置容器卷的读写权限,默认是读写权限,如果只想读取,可以设置为只读权限(这里的只读指的是在容器内指定目录下只读,对其他目录没有限制)
        docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名        ro即read only,容器内只读权限 默认是rw即可读可写

6.容器卷的继承和共享
    1.可以在创建一个新容器时,通过--volumes-from标记来从另一个容器或者服务挂载一个或者多个数据卷(主要)
        docker run -it --privileged=true --volumes-from 容器名 镜像名
    2.可以从已经存在的容器创建一个新的带有数据卷的容器,并且可以指定新容器挂载已存在容器的某个数据卷(了解)
        docker run -it --privileged=true --volumes-from 容器名:挂载的数据卷名 镜像名
    3.可以从已经存在的容器创建一个新的带有数据卷的容器,并且可以指定新容器挂载已存在容器的某个数据卷,并且可以指定挂载的数据卷的权限(了解)
        docker run -it --privileged=true --volumes-from 容器名:挂载的数据卷名:ro 镜像名

    实例：
    docker run -it --privileged=true -v /usr/local/tmp/host_data:/usr/local/tmp/u_data --name=w1 ubuntu
    docker run -it --privileged=true --volumes-from w1 --name=w2 ubuntu
    这两条命令的意思是,在w2容器中挂载w1容器中的数据卷,并且挂载的数据卷的权限是可读可写的
    此时w2的容器中是含有w1容器中的数据的,并且可以对w1容器中的数据进行读写操作
    那么如果我们此时关闭w1容器,并且修改主机容器卷内的数据,会发现w2容器中的数据依然可以跟主机同步,并且此时修改的数据也会同步到主机中,
实际上就是相当于把w2也挂载到了主机的容器卷中,并且是双向同步的,单看w2会发现继承挂载与直接挂载其实没啥区别,只是继承挂载的数据卷是从某个容器中继承过来的,会直接拥有该容器的一些原始数据
单如果再看我w1,会发现此时如果重启w1,在w1宕机期间,w2中创建的数据也会被同步给w1,这就是继承挂载的好处,这也很好理解,毕竟w2跟主机互通,而w1即使掉线了之后也是从主机中读取数据的,所以w1重启后会同步w2的数据