1.Docker之所以发展迅速,是因为它可以实现―――――系统平滑移植,容器虚拟化技术;解决了复杂的环境部署问题,以往我们的工作流程是开发提供一个jar包,然后运维
部署一个与我们一致的开发环境,最后将程序运行,但是部署环境的这个过程是复杂且容易出现一些问题的;而docker呢可以实现将代码和环境一起移植过来――――――docker镜像;

2.docker和虚拟机的区别
传统虚拟机是模拟出一套硬件,在其上运行一个完整的操作系统,进而在该系统上运行应用进程,所以我们安装的虚拟机镜像通常都很大
而docker是基于容器的虚拟化,仅包含业务运行所需的runtime环境,CentOS基础镜像仅170M,容器内的应用进程是直接运行于宿主的内核,容器内没有自己的内核,也没有进行硬件虚拟,所以docker更轻量
宿主机可部署100~1000个容器,并且各个容器之间相互隔离,互不影响
一个docker是一条鲸鱼,各个集装箱就是各个中间件(redis,mongodb,mysql),他们虽然都装载在同一个docker上,但是并不会相互影响,每个容器有自己的文件系统,能区分计算资源

3.docker能解决什么问题
docker使得应用的升级变得非常容易,当现有容器不足以支撑业务时,可以通过镜像运行新的容器来进行快速扩容,使得应用系统的扩容这个工作量由原来的天级变成分钟甚至秒级

4.docker三要素
镜像  容器  仓库
docker的镜像文件类似于Java的类模板;而docker容器实例类似于Java中new出来的对象
假如我们想在docker上部署一个一主两从的redis集群,我们只需要创建三个redis容器进而配置即可;而如果我们要在虚拟机实现,就需要开启三台虚拟机才可以搭建集群,很明显docker更加轻量快捷
仓库是集中存放镜像文件的地方
镜像文件可以看作容器的模板,Docker根据镜像生成容器实例,同一个镜像文件可以生成多个同时运行的容器实例

5.docker的虚悬镜像是什么
仓库名、标签都是<none>的镜像,俗称虚悬镜像dangling image
当我们删除一个容器时,并不会删除其镜像,而是将其镜像标记为虚悬镜像,我们可以通过docker images -f dangling=true查看虚悬镜像,
我们可以通过docker rmi $(docker images -f dangling=true -q)删除所有虚悬镜像

6.镜像的分层概念
UnionFS(联合文件系统)：一种分层、轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下;
                    UnionFS是Docker镜像的基础,镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像
特性：一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录
     如果上层和下层有相同的文件,上层的文件会覆盖下层的文件,这样最终的文件系统会包含所有层的文件和目录
概念：docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS的特点就是镜像的分层,镜像构建时,会一层层构建,前一层是后一层的基础,
     每一层构建完毕后,都会提交一个唯一的镜像ID,这样构建出来的镜像就是一个层层递进的镜像
好处：最大的好处就是共享资源,方便迁移复制,就是为了复用
     比如说有多个镜像都是从相同的base镜像构建而来的,那么宿主机只需要在磁盘上保存一份base镜像,同时内存中也只需要加载一份base镜像,就可以为所有容器服务了
注意：docker的镜像层都是只读的,容器层是可写的
     当容器启动时,一个新的可写层被加载到镜像的顶部,这一层通常被称作"容器层","容器层"之下的都叫"镜像层"